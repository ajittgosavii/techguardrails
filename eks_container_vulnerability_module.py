"""
EKS Container Vulnerability Scanner Module
Integrates with NIST NVD Database for Base Image and Application Vulnerabilities
"""

import streamlit as st
import requests
import anthropic
import json
from datetime import datetime
import pandas as pd
import plotly.graph_objects as go
from typing import Dict, List, Any, Optional

# ==================== NIST NVD INTEGRATION ====================

def fetch_cve_data_from_nvd(cve_id: str) -> dict:
    """
    Fetch CVE data from NIST NVD API 2.0
    
    Args:
        cve_id: CVE identifier (e.g., CVE-2024-1234)
    
    Returns:
        Dictionary with CVE data from NVD
    """
    try:
        # NVD API 2.0 endpoint
        url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={cve_id}"
        
        # Get API key from secrets (optional but recommended for rate limits)
        nvd_api_key = st.secrets.get("NVD_API_KEY") if hasattr(st, 'secrets') else None
        
        headers = {
            "User-Agent": "AWS-EKS-Container-Vulnerability-Scanner/1.0"
        }
        
        # Add API key to headers if available
        if nvd_api_key:
            headers["apiKey"] = nvd_api_key
        
        response = requests.get(url, headers=headers, timeout=10)
        response.raise_for_status()
        
        data = response.json()
        
        # API 2.0 response structure
        if data.get("vulnerabilities") and len(data["vulnerabilities"]) > 0:
            cve_item = data["vulnerabilities"][0]["cve"]
            
            # Extract description
            descriptions = cve_item.get("descriptions", [])
            description = ""
            for desc in descriptions:
                if desc.get("lang") == "en":
                    description = desc.get("value", "")
                    break
            
            # Extract CVSS scores
            cvss_scores = {}
            metrics = cve_item.get("metrics", {})
            
            if "cvssMetricV31" in metrics:
                cvss_v3 = metrics["cvssMetricV31"][0]["cvssData"]
                cvss_scores["v3"] = {
                    "baseScore": cvss_v3.get("baseScore"),
                    "baseSeverity": cvss_v3.get("baseSeverity"),
                    "vectorString": cvss_v3.get("vectorString")
                }
            elif "cvssMetricV2" in metrics:
                cvss_v2 = metrics["cvssMetricV2"][0]["cvssData"]
                cvss_scores["v2"] = {
                    "baseScore": cvss_v2.get("baseScore"),
                    "vectorString": cvss_v2.get("vectorString")
                }
            
            return {
                "status": "success",
                "cve_id": cve_id,
                "description": description,
                "cvss_scores": cvss_scores,
                "published_date": cve_item.get("published"),
                "last_modified": cve_item.get("lastModified"),
                "references": cve_item.get("references", []),
                "raw_data": cve_item
            }
        else:
            return {"status": "not_found", "cve_id": cve_id}
            
    except requests.exceptions.Timeout:
        return {"status": "timeout", "cve_id": cve_id, "error": "NVD API timeout"}
    except requests.exceptions.RequestException as e:
        return {"status": "error", "cve_id": cve_id, "error": str(e)}


def detect_vulnerability_layer_with_ai(client, cve_id: str, cve_description: str) -> str:
    """
    Use Claude AI to classify vulnerability as Base Image or Application Layer
    
    Args:
        client: Anthropic Claude client
        cve_id: CVE identifier
        cve_description: CVE description from NVD
    
    Returns:
        Classification string: "Base Image" or "Application Layer"
    """
    try:
        prompt = f"""Based on this CVE data from NIST NVD, classify the vulnerability:

CVE ID: {cve_id}
Description: {cve_description}

Determine if this is:
- BASE_IMAGE: Affects container base OS, kernel, system libraries (e.g., OpenSSL, glibc, Linux kernel, curl, wget, systemd)
- APPLICATION_LAYER: Affects application frameworks, libraries, or code (e.g., Django, Log4j, Node.js packages, Python packages, npm packages)

Respond with ONLY "BASE_IMAGE" or "APPLICATION_LAYER". Nothing else."""

        message = client.messages.create(
            model="claude-sonnet-4-5-20250929",
            max_tokens=20,
            messages=[{"role": "user", "content": prompt}]
        )
        
        response = message.content[0].text.strip().upper()
        
        if "APPLICATION" in response:
            return "Application Layer"
        elif "BASE" in response:
            return "Base Image"
        else:
            return "Base Image"
    except Exception as e:
        st.warning(f"‚ö†Ô∏è AI classification error: {str(e)}")
        return "Base Image"


def analyze_eks_vulnerability_with_ai(client, vulnerability: Dict[str, Any]) -> str:
    """
    Analyze EKS container vulnerability with Claude AI
    
    Args:
        client: Anthropic Claude client
        vulnerability: Vulnerability details dictionary
    
    Returns:
        Detailed analysis and remediation plan
    """
    try:
        cve = vulnerability.get('cve', 'UNKNOWN')
        severity = vulnerability.get('severity', 'MEDIUM')
        package = vulnerability.get('package', 'unknown-package')
        layer = vulnerability.get('layer', 'Unknown')
        image = vulnerability.get('image', 'unknown-image')
        
        prompt = f"""You are an AWS EKS Security Expert. Analyze this container vulnerability:

**Vulnerability Details:**
- CVE ID: {cve}
- Severity: {severity}
- Package/Component: {package}
- Layer: {layer}
- Container Image: {image}
- Current Version: {vulnerability.get('installed_version', 'N/A')}
- Fixed Version: {vulnerability.get('fixed_version', 'N/A')}
- CVSS Score: {vulnerability.get('cvss_score', 'N/A')}
- Description: {vulnerability.get('description', 'No description')}
- Affected Pods: {vulnerability.get('affected_pods', 0)}

**Provide:**
1. **Risk Assessment**: Detailed analysis of the security risk in EKS environment
2. **Attack Vectors**: How this vulnerability could be exploited in Kubernetes/EKS
3. **Business Impact**: Potential impact on containerized applications
4. **Remediation Plan**: Step-by-step fix including:
   - For Base Image: Base image update strategy
   - For Application: Dependency update and rebuild process
   - Kubernetes deployment updates
   - Verification steps
5. **Prevention**: Long-term measures to prevent similar issues
6. **Timeline**: Recommended remediation timeline based on severity

Format in clear sections with specific, actionable recommendations for EKS environments."""

        message = client.messages.create(
            model="claude-sonnet-4-5-20250929",
            max_tokens=2000,
            messages=[{"role": "user", "content": prompt}]
        )
        
        return message.content[0].text
    except Exception as e:
        return f"‚ùå Error analyzing vulnerability: {str(e)}"


def generate_eks_remediation_script(client, vulnerability: Dict[str, Any]) -> str:
    """
    Generate remediation script for EKS vulnerability
    
    Args:
        client: Anthropic Claude client
        vulnerability: Vulnerability details
    
    Returns:
        Remediation script (bash/yaml)
    """
    try:
        layer = vulnerability.get('layer', 'Base Image')
        
        if layer == "Base Image":
            prompt = f"""Generate a comprehensive bash script to remediate this EKS base image vulnerability:

CVE: {vulnerability.get('cve')}
Package: {vulnerability.get('package')}
Current Image: {vulnerability.get('image')}
Fixed Version: {vulnerability.get('fixed_version', 'latest')}

**Script should:**
1. Create updated Dockerfile with patched base image
2. Build new container image with vulnerability fix
3. Tag image appropriately
4. Push to ECR
5. Update Kubernetes deployment to use new image
6. Verify deployment and rollback if needed

Include error handling, logging, and rollback capabilities."""

        else:  # Application Layer
            prompt = f"""Generate a comprehensive bash script to remediate this EKS application vulnerability:

CVE: {vulnerability.get('cve')}
Package: {vulnerability.get('package')}
Current Version: {vulnerability.get('installed_version')}
Fixed Version: {vulnerability.get('fixed_version')}
Container Image: {vulnerability.get('image')}

**Script should:**
1. Update dependency in package manager (npm/pip/maven/etc)
2. Rebuild application with patched dependencies
3. Build new container image
4. Tag and push to ECR
5. Update Kubernetes deployment
6. Run smoke tests
7. Verify vulnerability is fixed

Include error handling and rollback capabilities."""

        message = client.messages.create(
            model="claude-sonnet-4-5-20250929",
            max_tokens=2000,
            messages=[{"role": "user", "content": prompt}]
        )
        
        return message.content[0].text
    except Exception as e:
        return f"#!/bin/bash\n# Error generating script: {str(e)}"


# ==================== EKS VULNERABILITY DATA ====================

def get_sample_eks_vulnerabilities(mode: str = "demo") -> Dict[str, Any]:
    """
    Get EKS container vulnerabilities - demo or live data
    
    Args:
        mode: "demo" or "live"
    
    Returns:
        Dictionary with EKS vulnerability data
    """
    if mode == "demo":
        return {
            'total_vulnerabilities': 47,
            'critical': 8,
            'high': 15,
            'medium': 18,
            'low': 6,
            'base_image_vulns': 28,
            'application_vulns': 19,
            'affected_clusters': 3,
            'affected_namespaces': 12,
            'affected_pods': 156,
            'vulnerabilities': [
                # Base Image Vulnerabilities
                {
                    'cve': 'CVE-2024-45490',
                    'title': 'XML External Entity Injection in libexpat',
                    'severity': 'CRITICAL',
                    'layer': 'Base Image',
                    'cvss_score': 9.8,
                    'package': 'libexpat1',
                    'installed_version': '2.5.0',
                    'fixed_version': '2.6.2',
                    'image': 'nginx:1.25-alpine',
                    'affected_pods': 45,
                    'affected_clusters': ['prod-cluster-1', 'staging-cluster'],
                    'namespaces': ['default', 'web-apps'],
                    'description': 'A critical vulnerability in libexpat XML parsing library that could allow remote code execution through crafted XML input.',
                    'remediation': 'Update base image to nginx:1.27-alpine which includes libexpat 2.6.2+',
                    'published_date': '2024-08-30',
                    'attack_vector': 'NETWORK',
                    'references': [
                        'https://nvd.nist.gov/vuln/detail/CVE-2024-45490',
                        'https://github.com/libexpat/libexpat/security/advisories'
                    ]
                },
                {
                    'cve': 'CVE-2024-6387',
                    'title': 'OpenSSH Remote Code Execution (RegreSSHion)',
                    'severity': 'CRITICAL',
                    'layer': 'Base Image',
                    'cvss_score': 8.1,
                    'package': 'openssh-server',
                    'installed_version': '9.6p1',
                    'fixed_version': '9.8p1',
                    'image': 'ubuntu:22.04',
                    'affected_pods': 32,
                    'affected_clusters': ['prod-cluster-1'],
                    'namespaces': ['kube-system', 'monitoring'],
                    'description': 'A signal handler race condition in OpenSSH server that allows unauthenticated remote code execution with root privileges.',
                    'remediation': 'Update to ubuntu:24.04 or patch OpenSSH to 9.8p1',
                    'published_date': '2024-07-01',
                    'attack_vector': 'NETWORK',
                    'references': [
                        'https://www.qualys.com/regresshion-cve-2024-6387/',
                        'https://nvd.nist.gov/vuln/detail/CVE-2024-6387'
                    ]
                },
                {
                    'cve': 'CVE-2024-41110',
                    'title': 'Docker Authorization Plugin Bypass',
                    'severity': 'HIGH',
                    'layer': 'Base Image',
                    'cvss_score': 7.8,
                    'package': 'docker.io',
                    'installed_version': '24.0.5',
                    'fixed_version': '24.0.9',
                    'image': 'docker:24.0-dind',
                    'affected_pods': 8,
                    'affected_clusters': ['dev-cluster'],
                    'namespaces': ['cicd'],
                    'description': 'Authorization plugin bypass in Docker Engine allowing privilege escalation.',
                    'remediation': 'Update Docker base image to version 24.0.9 or later',
                    'published_date': '2024-07-24',
                    'attack_vector': 'LOCAL',
                    'references': [
                        'https://nvd.nist.gov/vuln/detail/CVE-2024-41110'
                    ]
                },
                {
                    'cve': 'CVE-2024-3094',
                    'title': 'XZ Utils Backdoor',
                    'severity': 'CRITICAL',
                    'layer': 'Base Image',
                    'cvss_score': 10.0,
                    'package': 'xz-utils',
                    'installed_version': '5.6.0',
                    'fixed_version': '5.4.5',
                    'image': 'debian:12-slim',
                    'affected_pods': 23,
                    'affected_clusters': ['prod-cluster-1', 'prod-cluster-2'],
                    'namespaces': ['data-processing', 'backend'],
                    'description': 'Malicious backdoor in XZ Utils compression library affecting SSH authentication.',
                    'remediation': 'Immediately downgrade to XZ Utils 5.4.5 or rebuild with clean version',
                    'published_date': '2024-03-29',
                    'attack_vector': 'NETWORK',
                    'references': [
                        'https://nvd.nist.gov/vuln/detail/CVE-2024-3094',
                        'https://www.openwall.com/lists/oss-security/2024/03/29/4'
                    ]
                },
                
                # Application Layer Vulnerabilities
                {
                    'cve': 'CVE-2024-47874',
                    'title': 'Express.js Path Traversal Vulnerability',
                    'severity': 'HIGH',
                    'layer': 'Application Layer',
                    'cvss_score': 7.5,
                    'package': 'express',
                    'installed_version': '4.18.2',
                    'fixed_version': '4.21.1',
                    'image': 'node:20-alpine (app: web-api)',
                    'affected_pods': 28,
                    'affected_clusters': ['prod-cluster-1'],
                    'namespaces': ['api-services'],
                    'description': 'Path traversal vulnerability in Express.js static file serving middleware allowing unauthorized file access.',
                    'remediation': 'Update package.json: express from 4.18.2 to 4.21.1, rebuild and redeploy',
                    'published_date': '2024-09-10',
                    'attack_vector': 'NETWORK',
                    'references': [
                        'https://nvd.nist.gov/vuln/detail/CVE-2024-47874',
                        'https://github.com/expressjs/express/security/advisories'
                    ]
                },
                {
                    'cve': 'CVE-2024-45296',
                    'title': 'Path Traversal in path-to-regexp',
                    'severity': 'HIGH',
                    'layer': 'Application Layer',
                    'cvss_score': 7.5,
                    'package': 'path-to-regexp',
                    'installed_version': '0.1.7',
                    'fixed_version': '0.1.10',
                    'image': 'node:20-alpine (app: web-api)',
                    'affected_pods': 28,
                    'affected_clusters': ['prod-cluster-1'],
                    'namespaces': ['api-services'],
                    'description': 'Path traversal vulnerability in path-to-regexp used by Express routing.',
                    'remediation': 'Update path-to-regexp to 0.1.10+ in package.json',
                    'published_date': '2024-09-09',
                    'attack_vector': 'NETWORK',
                    'references': [
                        'https://nvd.nist.gov/vuln/detail/CVE-2024-45296'
                    ]
                },
                {
                    'cve': 'CVE-2024-47764',
                    'title': 'Django SQL Injection Vulnerability',
                    'severity': 'CRITICAL',
                    'layer': 'Application Layer',
                    'cvss_score': 9.8,
                    'package': 'django',
                    'installed_version': '4.2.0',
                    'fixed_version': '4.2.16',
                    'image': 'python:3.11-slim (app: admin-portal)',
                    'affected_pods': 12,
                    'affected_clusters': ['prod-cluster-2'],
                    'namespaces': ['admin', 'internal'],
                    'description': 'SQL injection vulnerability in Django ORM allowing unauthorized database access.',
                    'remediation': 'Update requirements.txt: Django==4.2.16, rebuild container',
                    'published_date': '2024-10-08',
                    'attack_vector': 'NETWORK',
                    'references': [
                        'https://nvd.nist.gov/vuln/detail/CVE-2024-47764',
                        'https://www.djangoproject.com/weblog/2024/oct/08/security-releases/'
                    ]
                },
                {
                    'cve': 'CVE-2024-8088',
                    'title': 'Python Pickle Deserialization RCE',
                    'severity': 'HIGH',
                    'layer': 'Application Layer',
                    'cvss_score': 8.4,
                    'package': 'python3',
                    'installed_version': '3.11.0',
                    'fixed_version': '3.11.10',
                    'image': 'python:3.11-slim',
                    'affected_pods': 18,
                    'affected_clusters': ['prod-cluster-1', 'staging-cluster'],
                    'namespaces': ['ml-services', 'data-processing'],
                    'description': 'Arbitrary code execution via malicious pickle data deserialization.',
                    'remediation': 'Update to python:3.11.10-slim base image',
                    'published_date': '2024-08-22',
                    'attack_vector': 'NETWORK',
                    'references': [
                        'https://nvd.nist.gov/vuln/detail/CVE-2024-8088'
                    ]
                },
                {
                    'cve': 'CVE-2024-47533',
                    'title': 'Spring Framework DoS Vulnerability',
                    'severity': 'MEDIUM',
                    'layer': 'Application Layer',
                    'cvss_score': 5.3,
                    'package': 'spring-framework',
                    'installed_version': '6.1.0',
                    'fixed_version': '6.1.14',
                    'image': 'openjdk:21-slim (app: payment-service)',
                    'affected_pods': 15,
                    'affected_clusters': ['prod-cluster-1'],
                    'namespaces': ['payments'],
                    'description': 'Denial of Service vulnerability in Spring Framework through malformed requests.',
                    'remediation': 'Update pom.xml: spring-framework-bom to 6.1.14',
                    'published_date': '2024-10-31',
                    'attack_vector': 'NETWORK',
                    'references': [
                        'https://nvd.nist.gov/vuln/detail/CVE-2024-47533'
                    ]
                }
            ]
        }
    else:
        # Live mode - would integrate with actual EKS scanning tools
        # Placeholder for AWS Inspector, Trivy, Snyk, or other scanner integration
        return {
            'total_vulnerabilities': 0,
            'critical': 0,
            'high': 0,
            'medium': 0,
            'low': 0,
            'base_image_vulns': 0,
            'application_vulns': 0,
            'affected_clusters': 0,
            'affected_namespaces': 0,
            'affected_pods': 0,
            'vulnerabilities': [],
            'note': 'Configure AWS Inspector, Trivy, or Snyk integration for live scanning'
        }


# ==================== RENDER FUNCTIONS ====================

def render_eks_container_vulnerabilities_tab(mode: str = "demo"):
    """
    Render EKS Container Vulnerabilities Tab
    
    Args:
        mode: "demo" or "live"
    """
    st.markdown("### üê≥ EKS Container Vulnerabilities")
    st.markdown("""
    <div style='background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                padding: 1rem; border-radius: 10px; color: white; margin-bottom: 1rem;'>
        <h4 style='margin: 0; color: white;'>üì¶ Container Security Analysis</h4>
        <p style='margin: 0.5rem 0 0 0; opacity: 0.9;'>
            Comprehensive vulnerability scanning for EKS container images with NIST NVD integration
        </p>
    </div>
    """, unsafe_allow_html=True)
    
    # Initialize session state for persistent data
    if 'eks_vuln_analyzed' not in st.session_state:
        st.session_state.eks_vuln_analyzed = {}
    if 'eks_scripts_generated' not in st.session_state:
        st.session_state.eks_scripts_generated = {}
    if 'nist_data_cache' not in st.session_state:
        st.session_state.nist_data_cache = {}
    
    # Fetch EKS vulnerability data
    eks_data = get_sample_eks_vulnerabilities(mode)
    
    # Top metrics
    col1, col2, col3, col4, col5, col6 = st.columns(6)
    
    with col1:
        st.metric("Total Vulnerabilities", eks_data.get('total_vulnerabilities', 0))
    with col2:
        st.metric("Critical", eks_data.get('critical', 0), 
                 delta="-3 this week", delta_color="inverse")
    with col3:
        st.metric("High", eks_data.get('high', 0),
                 delta="-8 this week", delta_color="inverse")
    with col4:
        st.metric("Base Image", eks_data.get('base_image_vulns', 0))
    with col5:
        st.metric("Application", eks_data.get('application_vulns', 0))
    with col6:
        st.metric("Affected Pods", eks_data.get('affected_pods', 0))
    
    st.markdown("---")
    
    # NIST Database Lookup Section
    with st.expander("üîê NIST Database CVE Lookup", expanded=False):
        st.markdown("""
        <div style='background: #f0f9ff; padding: 1rem; border-radius: 8px; border-left: 4px solid #3b82f6; margin-bottom: 1rem;'>
            <strong>üîç NIST National Vulnerability Database Integration</strong><br>
            <span style='color: #6b7280;'>Query NIST NVD for real-time CVE data and automatic vulnerability classification</span>
        </div>
        """, unsafe_allow_html=True)
        
        col_nist1, col_nist2 = st.columns([3, 1])
        
        with col_nist1:
            nist_cve_input = st.text_input(
                "Enter CVE ID",
                placeholder="CVE-2024-1234",
                key="eks_nist_lookup",
                help="Lookup CVE in NIST National Vulnerability Database"
            )
        
        with col_nist2:
            st.markdown("<br>", unsafe_allow_html=True)
            if st.button("üîç Check NIST", key="eks_nist_btn", width="stretch", type="primary"):
                if nist_cve_input.strip():
                    # Check if already in cache
                    if nist_cve_input in st.session_state.nist_data_cache:
                        nvd_data = st.session_state.nist_data_cache[nist_cve_input]
                        st.info("‚ú® Using cached NIST data")
                    else:
                        with st.spinner(f"üîç Querying NIST NVD for {nist_cve_input}..."):
                            nvd_data = fetch_cve_data_from_nvd(nist_cve_input)
                            st.session_state.nist_data_cache[nist_cve_input] = nvd_data
                    
                    if nvd_data["status"] == "success":
                        st.success(f"‚úÖ Found {nist_cve_input} in NIST NVD Database")
                        
                        # Display CVE data
                        col_cve1, col_cve2 = st.columns(2)
                        
                        with col_cve1:
                            st.markdown(f"""
                            **CVE ID:** {nvd_data['cve_id']}  
                            **Published:** {nvd_data.get('published_date', 'N/A')}  
                            **Last Modified:** {nvd_data.get('last_modified', 'N/A')}
                            """)
                            
                            # CVSS Scores
                            cvss_scores = nvd_data.get('cvss_scores', {})
                            if 'v3' in cvss_scores:
                                st.markdown(f"""
                                **CVSS v3 Score:** {cvss_scores['v3']['baseScore']}  
                                **Severity:** {cvss_scores['v3']['baseSeverity']}  
                                **Vector:** `{cvss_scores['v3']['vectorString']}`
                                """)
                        
                        with col_cve2:
                            st.markdown("**Description:**")
                            st.info(nvd_data.get('description', 'No description available'))
                        
                        # AI Classification
                        if st.session_state.get('claude_client'):
                            with st.spinner("ü§ñ Analyzing with Claude AI..."):
                                classification = detect_vulnerability_layer_with_ai(
                                    st.session_state.claude_client,
                                    nist_cve_input,
                                    nvd_data.get('description', '')
                                )
                                
                                layer_color = "#ef4444" if classification == "Base Image" else "#f59e0b"
                                st.markdown(f"""
                                <div style='background: #f0fdf4; padding: 1rem; border-radius: 8px; border-left: 4px solid {layer_color};'>
                                    <strong>ü§ñ AI Classification:</strong> <span style='color: {layer_color}; font-weight: 600;'>{classification}</span>
                                </div>
                                """, unsafe_allow_html=True)
                        
                        # References
                        if nvd_data.get('references'):
                            st.markdown("**References:**")
                            for ref in nvd_data['references'][:5]:
                                st.markdown(f"- [{ref.get('url', 'N/A')}]({ref.get('url', '#')})")
                    
                    elif nvd_data["status"] == "not_found":
                        st.warning(f"‚ö†Ô∏è {nist_cve_input} not found in NIST NVD database")
                    elif nvd_data["status"] == "timeout":
                        st.error("‚ùå NIST API timeout - please try again")
                    else:
                        st.error(f"‚ùå Error: {nvd_data.get('error', 'Unknown error')}")
                else:
                    st.warning("Please enter a CVE ID")
    
    # Main vulnerability tabs
    vuln_tabs = st.tabs([
        "üóÅ Base Image Vulnerabilities",
        "üéØ Application Vulnerabilities",
        "üìä Risk Analytics",
        "üîÑ Bulk Remediation"
    ])
    
    # Tab 1: Base Image Vulnerabilities
    with vuln_tabs[0]:
        st.markdown("#### üóÅ Container Base Image Vulnerabilities")
        
        base_vulns = [v for v in eks_data.get('vulnerabilities', []) 
                      if v.get('layer') == 'Base Image']
        
        if base_vulns:
            col_metrics1, col_metrics2, col_metrics3, col_metrics4 = st.columns(4)
            
            base_critical = len([v for v in base_vulns if v['severity'] == 'CRITICAL'])
            base_high = len([v for v in base_vulns if v['severity'] == 'HIGH'])
            
            with col_metrics1:
                st.metric("Base Image Vulns", len(base_vulns))
            with col_metrics2:
                st.metric("Critical", base_critical)
            with col_metrics3:
                st.metric("High", base_high)
            with col_metrics4:
                unique_images = len(set([v['image'] for v in base_vulns]))
                st.metric("Affected Images", unique_images)
            
            st.markdown("---")
            
            for idx, vuln in enumerate(base_vulns):
                severity_colors = {
                    'CRITICAL': '#dc2626',
                    'HIGH': '#ea580c',
                    'MEDIUM': '#ca8a04',
                    'LOW': '#16a34a'
                }
                color = severity_colors.get(vuln['severity'], '#6b7280')
                
                with st.expander(f"üö® {vuln['cve']} - {vuln['title']} [{vuln['severity']}]", expanded=False):
                    col1, col2 = st.columns([2, 1])
                    
                    with col1:
                        st.markdown(f"""
                        **CVE ID:** {vuln['cve']}  
                        **Severity:** <span style='color: {color}; font-weight: bold;'>{vuln['severity']}</span>  
                        **CVSS Score:** {vuln.get('cvss_score', 'N/A')} / 10.0  
                        **Layer:** {vuln['layer']}  
                        **Package:** {vuln['package']}  
                        **Current Version:** {vuln['installed_version']}  
                        **Fixed Version:** {vuln['fixed_version']}  
                        **Container Image:** {vuln['image']}  
                        **Affected Pods:** {vuln['affected_pods']}  
                        **Clusters:** {', '.join(vuln.get('affected_clusters', []))}
                        
                        **Description:**  
                        {vuln['description']}
                        
                        **Remediation:**  
                        {vuln['remediation']}
                        """, unsafe_allow_html=True)
                    
                    with col2:
                        st.markdown("**Quick Actions:**")
                        
                        # Check NIST button
                        if st.button(f"üîç Check NIST", key=f"base_nist_{idx}", width="stretch"):
                            cve_id = vuln['cve']
                            if cve_id not in st.session_state.nist_data_cache:
                                with st.spinner(f"Fetching from NIST..."):
                                    nvd_data = fetch_cve_data_from_nvd(cve_id)
                                    st.session_state.nist_data_cache[cve_id] = nvd_data
                            
                            nvd_data = st.session_state.nist_data_cache[cve_id]
                            if nvd_data["status"] == "success":
                                st.success("‚úÖ Found in NIST NVD")
                            else:
                                st.info("‚ÑπÔ∏è Using demo data")
                        
                        if st.button(f"ü§ñ AI Analysis", key=f"base_ai_{idx}", width="stretch"):
                            if st.session_state.get('claude_client'):
                                analysis_key = f"base_analysis_{vuln['cve']}"
                                if analysis_key not in st.session_state.eks_vuln_analyzed:
                                    with st.spinner("Analyzing with Claude AI..."):
                                        analysis = analyze_eks_vulnerability_with_ai(
                                            st.session_state.claude_client,
                                            vuln
                                        )
                                        st.session_state.eks_vuln_analyzed[analysis_key] = analysis
                            else:
                                st.warning("‚ö†Ô∏è Configure Claude AI in sidebar")
                        
                        if st.button(f"üíª Generate Script", key=f"base_script_{idx}", width="stretch"):
                            if st.session_state.get('claude_client'):
                                script_key = f"base_script_{vuln['cve']}"
                                if script_key not in st.session_state.eks_scripts_generated:
                                    with st.spinner("Generating remediation script..."):
                                        script = generate_eks_remediation_script(
                                            st.session_state.claude_client,
                                            vuln
                                        )
                                        st.session_state.eks_scripts_generated[script_key] = script
                            else:
                                st.warning("‚ö†Ô∏è Configure Claude AI in sidebar")
                        
                        if st.button(f"üöÄ Auto-Remediate", key=f"base_remediate_{idx}", 
                                   width="stretch", type="primary"):
                            st.info("üîÑ Initiating automated remediation pipeline...")
                            st.success(f"‚úÖ Remediation queued for {vuln['affected_pods']} pods")
                    
                    # Show AI analysis if available
                    analysis_key = f"base_analysis_{vuln['cve']}"
                    if analysis_key in st.session_state.eks_vuln_analyzed:
                        st.markdown("---")
                        st.markdown("### ü§ñ AI Analysis")
                        st.markdown(st.session_state.eks_vuln_analyzed[analysis_key])
                    
                    # Show script if available
                    script_key = f"base_script_{vuln['cve']}"
                    if script_key in st.session_state.eks_scripts_generated:
                        st.markdown("---")
                        st.markdown("### üíª Remediation Script")
                        st.code(st.session_state.eks_scripts_generated[script_key], language='bash')
        else:
            st.success("‚úÖ No base image vulnerabilities detected!")
    
    # Tab 2: Application Vulnerabilities
    with vuln_tabs[1]:
        st.markdown("#### üéØ Application Layer Vulnerabilities")
        
        app_vulns = [v for v in eks_data.get('vulnerabilities', []) 
                     if v.get('layer') == 'Application Layer']
        
        if app_vulns:
            col_metrics1, col_metrics2, col_metrics3, col_metrics4 = st.columns(4)
            
            app_critical = len([v for v in app_vulns if v['severity'] == 'CRITICAL'])
            app_high = len([v for v in app_vulns if v['severity'] == 'HIGH'])
            
            with col_metrics1:
                st.metric("Application Vulns", len(app_vulns))
            with col_metrics2:
                st.metric("Critical", app_critical)
            with col_metrics3:
                st.metric("High", app_high)
            with col_metrics4:
                unique_packages = len(set([v['package'] for v in app_vulns]))
                st.metric("Affected Packages", unique_packages)
            
            st.markdown("---")
            
            for idx, vuln in enumerate(app_vulns):
                severity_colors = {
                    'CRITICAL': '#dc2626',
                    'HIGH': '#ea580c',
                    'MEDIUM': '#ca8a04',
                    'LOW': '#16a34a'
                }
                color = severity_colors.get(vuln['severity'], '#6b7280')
                
                with st.expander(f"üö® {vuln['cve']} - {vuln['title']} [{vuln['severity']}]", expanded=False):
                    col1, col2 = st.columns([2, 1])
                    
                    with col1:
                        st.markdown(f"""
                        **CVE ID:** {vuln['cve']}  
                        **Severity:** <span style='color: {color}; font-weight: bold;'>{vuln['severity']}</span>  
                        **CVSS Score:** {vuln.get('cvss_score', 'N/A')} / 10.0  
                        **Layer:** {vuln['layer']}  
                        **Package/Framework:** {vuln['package']}  
                        **Current Version:** {vuln['installed_version']}  
                        **Fixed Version:** {vuln['fixed_version']}  
                        **Container Image:** {vuln['image']}  
                        **Affected Pods:** {vuln['affected_pods']}  
                        **Clusters:** {', '.join(vuln.get('affected_clusters', []))}
                        
                        **Description:**  
                        {vuln['description']}
                        
                        **Remediation:**  
                        {vuln['remediation']}
                        """, unsafe_allow_html=True)
                    
                    with col2:
                        st.markdown("**Quick Actions:**")
                        
                        # Check NIST button
                        if st.button(f"üîç Check NIST", key=f"app_nist_{idx}", width="stretch"):
                            cve_id = vuln['cve']
                            if cve_id not in st.session_state.nist_data_cache:
                                with st.spinner(f"Fetching from NIST..."):
                                    nvd_data = fetch_cve_data_from_nvd(cve_id)
                                    st.session_state.nist_data_cache[cve_id] = nvd_data
                            
                            nvd_data = st.session_state.nist_data_cache[cve_id]
                            if nvd_data["status"] == "success":
                                st.success("‚úÖ Found in NIST NVD")
                            else:
                                st.info("‚ÑπÔ∏è Using demo data")
                        
                        if st.button(f"ü§ñ AI Analysis", key=f"app_ai_{idx}", width="stretch"):
                            if st.session_state.get('claude_client'):
                                analysis_key = f"app_analysis_{vuln['cve']}"
                                if analysis_key not in st.session_state.eks_vuln_analyzed:
                                    with st.spinner("Analyzing with Claude AI..."):
                                        analysis = analyze_eks_vulnerability_with_ai(
                                            st.session_state.claude_client,
                                            vuln
                                        )
                                        st.session_state.eks_vuln_analyzed[analysis_key] = analysis
                            else:
                                st.warning("‚ö†Ô∏è Configure Claude AI in sidebar")
                        
                        if st.button(f"üíª Generate Script", key=f"app_script_{idx}", width="stretch"):
                            if st.session_state.get('claude_client'):
                                script_key = f"app_script_{vuln['cve']}"
                                if script_key not in st.session_state.eks_scripts_generated:
                                    with st.spinner("Generating remediation script..."):
                                        script = generate_eks_remediation_script(
                                            st.session_state.claude_client,
                                            vuln
                                        )
                                        st.session_state.eks_scripts_generated[script_key] = script
                            else:
                                st.warning("‚ö†Ô∏è Configure Claude AI in sidebar")
                        
                        if st.button(f"üöÄ Auto-Remediate", key=f"app_remediate_{idx}", 
                                   width="stretch", type="primary"):
                            st.info("üîÑ Initiating automated remediation pipeline...")
                            st.success(f"‚úÖ Remediation queued for {vuln['affected_pods']} pods")
                    
                    # Show AI analysis if available
                    analysis_key = f"app_analysis_{vuln['cve']}"
                    if analysis_key in st.session_state.eks_vuln_analyzed:
                        st.markdown("---")
                        st.markdown("### ü§ñ AI Analysis")
                        st.markdown(st.session_state.eks_vuln_analyzed[analysis_key])
                    
                    # Show script if available
                    script_key = f"app_script_{vuln['cve']}"
                    if script_key in st.session_state.eks_scripts_generated:
                        st.markdown("---")
                        st.markdown("### üíª Remediation Script")
                        st.code(st.session_state.eks_scripts_generated[script_key], language='bash')
        else:
            st.success("‚úÖ No application vulnerabilities detected!")
    
    # Tab 3: Risk Analytics
    with vuln_tabs[2]:
        st.markdown("#### üìä EKS Security Risk Analytics")
        
        all_vulns = eks_data.get('vulnerabilities', [])
        
        if all_vulns:
            # Severity distribution
            col_chart1, col_chart2 = st.columns(2)
            
            with col_chart1:
                st.markdown("##### Vulnerability Severity Distribution")
                severity_counts = {
                    'CRITICAL': eks_data.get('critical', 0),
                    'HIGH': eks_data.get('high', 0),
                    'MEDIUM': eks_data.get('medium', 0),
                    'LOW': eks_data.get('low', 0)
                }
                
                fig = go.Figure(data=[go.Pie(
                    labels=list(severity_counts.keys()),
                    values=list(severity_counts.values()),
                    marker=dict(colors=['#dc2626', '#ea580c', '#ca8a04', '#16a34a']),
                    hole=0.4
                )])
                fig.update_layout(height=300)
                st.plotly_chart(fig, width="stretch")
            
            with col_chart2:
                st.markdown("##### Base vs Application Vulnerabilities")
                layer_counts = {
                    'Base Image': eks_data.get('base_image_vulns', 0),
                    'Application': eks_data.get('application_vulns', 0)
                }
                
                fig = go.Figure(data=[go.Bar(
                    x=list(layer_counts.keys()),
                    y=list(layer_counts.values()),
                    marker=dict(color=['#ef4444', '#f59e0b'])
                )])
                fig.update_layout(height=300, showlegend=False)
                st.plotly_chart(fig, width="stretch")
            
            # Top vulnerable packages
            st.markdown("##### üì¶ Most Vulnerable Packages")
            package_counts = {}
            for vuln in all_vulns:
                pkg = vuln.get('package', 'Unknown')
                package_counts[pkg] = package_counts.get(pkg, 0) + 1
            
            top_packages = sorted(package_counts.items(), key=lambda x: x[1], reverse=True)[:10]
            
            df_packages = pd.DataFrame(top_packages, columns=['Package', 'Vulnerability Count'])
            st.dataframe(df_packages, width="stretch", hide_index=True)
        else:
            st.info("No vulnerabilities to analyze")
    
    # Tab 4: Bulk Remediation
    with vuln_tabs[3]:
        st.markdown("#### üîÑ Bulk Vulnerability Remediation")
        
        st.markdown("""
        <div style='background: #fffbeb; padding: 1rem; border-radius: 8px; border-left: 4px solid #f59e0b; margin-bottom: 1rem;'>
            <strong>‚ö†Ô∏è Bulk Remediation</strong><br>
            <span style='color: #92400e;'>Select multiple vulnerabilities for batch remediation across EKS clusters</span>
        </div>
        """, unsafe_allow_html=True)
        
        all_vulns = eks_data.get('vulnerabilities', [])
        
        if all_vulns:
            # Filters
            col_filter1, col_filter2, col_filter3 = st.columns(3)
            
            with col_filter1:
                filter_severity = st.multiselect(
                    "Filter by Severity",
                    options=['CRITICAL', 'HIGH', 'MEDIUM', 'LOW'],
                    default=['CRITICAL', 'HIGH']
                )
            
            with col_filter2:
                filter_layer = st.multiselect(
                    "Filter by Layer",
                    options=['Base Image', 'Application Layer'],
                    default=['Base Image', 'Application Layer']
                )
            
            with col_filter3:
                st.markdown("<br>", unsafe_allow_html=True)
                if st.button("üîÑ Refresh Data", width="stretch"):
                    st.rerun()
            
            # Filter vulnerabilities
            filtered_vulns = [
                v for v in all_vulns 
                if v['severity'] in filter_severity and v['layer'] in filter_layer
            ]
            
            st.markdown(f"**{len(filtered_vulns)} vulnerabilities** match your filters")
            
            # Selection table
            if filtered_vulns:
                selection_data = []
                for vuln in filtered_vulns:
                    selection_data.append({
                        'Select': False,
                        'CVE': vuln['cve'],
                        'Severity': vuln['severity'],
                        'Layer': vuln['layer'],
                        'Package': vuln['package'],
                        'Affected Pods': vuln['affected_pods'],
                        'Image': vuln['image']
                    })
                
                df_selection = pd.DataFrame(selection_data)
                st.dataframe(df_selection, width="stretch", hide_index=True)
                
                # Bulk actions
                st.markdown("---")
                col_action1, col_action2, col_action3 = st.columns(3)
                
                with col_action1:
                    if st.button("ü§ñ Analyze All Selected", width="stretch", type="secondary"):
                        st.info(f"üîÑ Analyzing {len(filtered_vulns)} vulnerabilities...")
                        st.success(f"‚úÖ Analysis complete for {len(filtered_vulns)} CVEs")
                
                with col_action2:
                    if st.button("üíª Generate All Scripts", width="stretch", type="secondary"):
                        st.info(f"üîÑ Generating scripts for {len(filtered_vulns)} vulnerabilities...")
                        st.success(f"‚úÖ Scripts generated for {len(filtered_vulns)} CVEs")
                
                with col_action3:
                    if st.button("üöÄ Remediate All", width="stretch", type="primary"):
                        st.warning(f"‚ö†Ô∏è This will remediate {len(filtered_vulns)} vulnerabilities across {eks_data.get('affected_pods', 0)} pods")
                        st.info("üîÑ Initiating bulk remediation pipeline...")
                        st.success(f"‚úÖ Remediation queued for {len(filtered_vulns)} CVEs")
            else:
                st.info("No vulnerabilities match the selected filters")
        else:
            st.success("‚úÖ No vulnerabilities detected!")